"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const _ = require("lodash");
const emmet = require("vscode-emmet-helper");
const vscode_languageserver_types_1 = require("vscode-languageserver-types");
const StylusSupremacy = require("stylus-supremacy");
const emmet_1 = require("../emmet");
const languageModelCache_1 = require("../../languageModelCache");
const completion_item_1 = require("./completion-item");
const symbols_finder_1 = require("./symbols-finder");
const stylus_hover_1 = require("./stylus-hover");
function getStylusMode(documentRegions) {
    const embeddedDocuments = languageModelCache_1.getLanguageModelCache(10, 60, document => documentRegions.get(document).getEmbeddedDocument('stylus'));
    let baseIndentShifted = false;
    let config = {};
    return {
        getId: () => 'stylus',
        configure(c) {
            baseIndentShifted = _.get(c, 'vetur.format.styleInitialIndent', false);
            config = c;
        },
        onDocumentRemoved() { },
        dispose() { },
        doComplete(document, position) {
            const embedded = embeddedDocuments.get(document);
            const lsCompletions = completion_item_1.provideCompletionItems(embedded, position);
            const lsItems = _.map(lsCompletions.items, i => {
                return Object.assign({}, i, { sortText: emmet_1.Priority.Platform + i.label });
            });
            const emmetCompletions = emmet.doComplete(document, position, 'stylus', config.emmet);
            if (!emmetCompletions) {
                return { isIncomplete: false, items: lsItems };
            }
            else {
                const emmetItems = _.map(emmetCompletions.items, i => {
                    return Object.assign({}, i, { sortText: emmet_1.Priority.Emmet + i.label });
                });
                return {
                    isIncomplete: emmetCompletions.isIncomplete,
                    items: _.concat(emmetItems, lsItems)
                };
            }
        },
        findDocumentSymbols(document) {
            const embedded = embeddedDocuments.get(document);
            return symbols_finder_1.provideDocumentSymbols(embedded);
        },
        doHover(document, position) {
            const embedded = embeddedDocuments.get(document);
            return stylus_hover_1.stylusHover(embedded, position);
        },
        format(document, range, formatParams) {
            if (config.vetur.format.defaultFormatter.stylus === 'none') {
                return [];
            }
            const embedded = embeddedDocuments.get(document);
            const inputText = embedded.getText();
            const tabStopChar = formatParams.insertSpaces ? ' '.repeat(formatParams.tabSize) : '\t';
            // Note that this would have been `document.eol` ideally
            const newLineChar = inputText.includes('\r\n') ? '\r\n' : '\n';
            // Determine the base indentation for the multi-line Stylus content
            let baseIndent = '';
            if (range.start.line !== range.end.line) {
                const styleTagLine = document.getText().split(/\r?\n/)[range.start.line];
                if (styleTagLine) {
                    baseIndent = _.get(styleTagLine.match(/^(\t|\s)+/), '0', '');
                }
            }
            // Add one more indentation when `vetur.format.styleInitialIndent` is set to `true`
            if (baseIndentShifted) {
                baseIndent += tabStopChar;
            }
            // Build the formatting options for Stylus Supremacy
            // See https://thisismanta.github.io/stylus-supremacy/#options
            const stylusSupremacyFormattingOptions = StylusSupremacy.createFormattingOptions(config.stylusSupremacy || {});
            const formattingOptions = Object.assign({}, stylusSupremacyFormattingOptions, { tabStopChar, newLineChar: '\n' });
            const formattedText = StylusSupremacy.format(inputText, formattingOptions);
            // Add the base indentation and correct the new line characters
            const outputText = ((range.start.line !== range.end.line ? '\n' : '') + formattedText)
                .split(/\n/)
                .map(line => (line.length > 0 ? baseIndent + line : ''))
                .join(newLineChar);
            return [vscode_languageserver_types_1.TextEdit.replace(range, outputText)];
        }
    };
}
exports.getStylusMode = getStylusMode;
exports.wordPattern = /(#?-?\d*\.\d\w*%?)|([$@#!.:]?[\w-?]+%?)|[$@#!.]/g;
//# sourceMappingURL=index.js.map