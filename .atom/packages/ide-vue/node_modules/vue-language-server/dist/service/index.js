"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const languageModes_1 = require("../modes/languageModes");
const nullMode_1 = require("../modes/nullMode");
const formatting_1 = require("./formatting");
function getVls() {
    let languageModes;
    const validation = {
        'vue-html': true,
        html: true,
        css: true,
        scss: true,
        less: true,
        postcss: true,
        javascript: true
    };
    return {
        initialize(workspacePath) {
            languageModes = languageModes_1.getLanguageModes(workspacePath);
        },
        configure(config) {
            const veturValidationOptions = config.vetur.validation;
            validation['vue-html'] = veturValidationOptions.template;
            validation.css = veturValidationOptions.style;
            validation.postcss = veturValidationOptions.style;
            validation.scss = veturValidationOptions.style;
            validation.less = veturValidationOptions.style;
            validation.javascript = veturValidationOptions.script;
            languageModes.getAllModes().forEach(m => {
                if (m.configure) {
                    m.configure(config);
                }
            });
        },
        format(doc, range, formattingOptions) {
            return formatting_1.format(languageModes, doc, range, formattingOptions);
        },
        validate(doc) {
            const diagnostics = [];
            if (doc.languageId === 'vue') {
                languageModes.getAllModesInDocument(doc).forEach(mode => {
                    if (mode.doValidation && validation[mode.getId()]) {
                        pushAll(diagnostics, mode.doValidation(doc));
                    }
                });
            }
            return diagnostics;
        },
        doComplete(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode) {
                if (mode.doComplete) {
                    return mode.doComplete(doc, position);
                }
            }
            return nullMode_1.NULL_COMPLETION;
        },
        doResolve(doc, languageId, item) {
            const mode = languageModes.getMode(languageId);
            if (mode && mode.doResolve && doc) {
                return mode.doResolve(doc, item);
            }
            return item;
        },
        doHover(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode && mode.doHover) {
                return mode.doHover(doc, position);
            }
            return nullMode_1.NULL_HOVER;
        },
        findDocumentHighlight(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode && mode.findDocumentHighlight) {
                return mode.findDocumentHighlight(doc, position);
            }
            return [];
        },
        findDefinition(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode && mode.findDefinition) {
                return mode.findDefinition(doc, position);
            }
            return [];
        },
        findReferences(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode && mode.findReferences) {
                return mode.findReferences(doc, position);
            }
            return [];
        },
        findDocumentLinks(doc, documentContext) {
            const links = [];
            languageModes.getAllModesInDocument(doc).forEach(m => {
                if (m.findDocumentLinks) {
                    pushAll(links, m.findDocumentLinks(doc, documentContext));
                }
            });
            return links;
        },
        findDocumentSymbols(doc) {
            const symbols = [];
            languageModes.getAllModesInDocument(doc).forEach(m => {
                if (m.findDocumentSymbols) {
                    pushAll(symbols, m.findDocumentSymbols(doc));
                }
            });
            return symbols;
        },
        findDocumentColors(doc) {
            const colors = [];
            languageModes.getAllModesInDocument(doc).forEach(m => {
                if (m.findDocumentColors) {
                    pushAll(colors, m.findDocumentColors(doc));
                }
            });
            return colors;
        },
        getColorPresentations(doc, color, range) {
            const mode = languageModes.getModeAtPosition(doc, range.start);
            if (mode && mode.getColorPresentations) {
                return mode.getColorPresentations(doc, color, range);
            }
            return [];
        },
        doSignatureHelp(doc, position) {
            const mode = languageModes.getModeAtPosition(doc, position);
            if (mode && mode.doSignatureHelp) {
                return mode.doSignatureHelp(doc, position);
            }
            return nullMode_1.NULL_SIGNATURE;
        },
        removeDocument(doc) {
            languageModes.onDocumentRemoved(doc);
        },
        dispose() {
            languageModes.dispose();
        }
    };
}
exports.getVls = getVls;
function pushAll(to, from) {
    if (from) {
        for (let i = 0; i < from.length; i++) {
            to.push(from[i]);
        }
    }
}
//# sourceMappingURL=index.js.map